@namespace(uri="http://anatlyzer/atl/errors", prefix="atl_errors")
package errors;

import "platform:/resource/anatlyzer.atl.typing/model/types.ecore";

class AnalysisResult {
   val Problem[*] problems;
   
}

abstract class AnalysisInfo {
   
}

abstract class Problem extends AnalysisInfo {
	val Problem[*] dependents;   

	attr String[1] description;
	attr SeverityKind[1] severity;
	attr boolean needsCSP = false;
}

enum SeverityKind {
   ERROR = 0;
   WARNING = 1;
   STYLE_SUGGESTION  = 3;
   PERFORMANCE_SUGGESTION = 4;
}

abstract class Recovery {   
}

@namespace(uri="http://bento/analysis/atl/analysis/errors", prefix="atl_error")
package atl_error {
	abstract class LocalProblem extends Problem {
	   attr String[1] location;
	   attr String[0..1] fileLocation;
	   ref  EObject[1] element;
	   
	   val Recovery[0..1] recovery;
	}

    class ModelElement {
    	ref EClass[1] klass;
    	attr String[1] metamodelName;
    }

 	// Problem kinds
	abstract class RuntimeError { }
	abstract class Warning { }
	abstract class StyleHint { }
	abstract class PerformanceHint { }
	

	abstract class OclCompliance { }	// needed?
	abstract class OclComplianceProblem extends LocalProblem {}
	
	abstract class NavigationProblem extends LocalProblem {	}
	abstract class InvalidArgumentProblem extends LocalProblem { }
	abstract class TargetModelConformanceProblem extends LocalProblem { }

	@description(name="Collection operation over no collection", example="aClassInstance->select(...)")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="navigation", phase="typing", source="OCL spec, tests")
	class CollectionOperationOverNoCollectionError extends NavigationProblem, RuntimeError {	      
	}
	
	@description(name="Feature access in collection", text="Collections do not have features. Dot-notation cannot be used over them", example="Sequence { }.length")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="navigation", phase="typing", source="OCL spec, tests")
	class FeatureAccessInCollection extends NavigationProblem, RuntimeError {
	    attr String[1] featureName;
	}
	
	@description(name="Feature not found", text="Feature cannot be found in an object's class")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")
	class FeatureNotFound extends NavigationProblem, RuntimeError {
		attr String[1] featureName;
		ref  types.Type[1] type;	   

		attr String[1] className;
		attr String[1] metamodelName;
	}

	@description(name="Feature found in subtype", text="Feature cannot be found in an object's class, but found in subtype. The error may not happen depending on the program logic.")	 
	@info(prec="sometimes-solver", path="yes", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")
	class FeatureFoundInSubtype extends FeatureNotFound, RuntimeError {
		ref EClass[*] possibleClasses;	
	}

	abstract class OperationCallInvalid extends NavigationProblem, RuntimeError {
		attr String[1] operationName;
		ref  types.Type[1] type;	   

		attr String[1] className;
		attr String[1] metamodelName;		
		
		ref types.Type[*] formalParameters;
		ref types.Type[*] actualParameters;
	}

	@description(name="Operation not found", text="Operation cannot be found in an object's class")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")	
	class OperationNotFound extends OperationCallInvalid, RuntimeError {
	}


	@description(name="Operation found in subtype", text="Operation cannot be found in an object's class, but found in subtype. The error may not happen depending on the program logic.")	 
	@info(prec="sometimes-solver", path="yes", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")
	class OperationFoundInSubtype extends OperationNotFound, RuntimeError {
		ref EClass[*] possibleClasses;	
	}

	@description(name="Invalid number of actual parameters", text="The number of actual parameters does not match the formal parameters")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")		
	class OperationCallInvalidNumberOfParameters extends OperationCallInvalid, RuntimeError {					
	}

	@description(name="Invalid actual parameter type", text="The types of the actual parameters does not match the formal parameters")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")			
	class OperationCallInvalidParameter extends OperationCallInvalid, RuntimeError {		
		attr String[*] blamedParameterNames;				
	}
	
	@description(name="Operation not found in ThisModule", text="Operation defined in the transformation scope cannot be found (i.e., invoked with thisModule.operation()).")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")	
	class OperationNotFoundInThisModule extends NavigationProblem, RuntimeError {
		attr String[1] name;
		attr boolean[1] maybeRule = false;
	}

	@description(name="Attribute not found in ThisModule", text="Attribute defined in the transformation scope cannot be found (i.e., invoked with thisModule.operation()).")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")		
	class AttributeNotFoundInThisModule extends NavigationProblem, RuntimeError {
		attr String[1] name;
	}

	@description(name="Feature not found in union type", text="Feature cannot be found in one or more of the possible types of an expression. Only applicable when an expression is deemed have several possible types.")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")		
	class FeatureNotFoundInUnionType extends NavigationProblem, RuntimeError {
		attr String[1] featureName;	   
	}
	
	@description(name="Invalid operator", text="Operator not applicable to a certain type.")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")		
	class InvalidOperand extends InvalidArgumentProblem, RuntimeError {
	   attr String[1] operatorSymbol;	   
	}	  

	@description(name="Object without container", text="A call to refImmediateComposite() will *always* result in OclUndefined.", example="
		Given a root class, e.g., MyClassModel, the expression
	    aClassModel.refImmediateComposite() will always return null.	
	")	 
	@info(prec="static", path="no", severity="runtime-error", when="model-dep", kind="src-typing", phase="typing", source="none")
	class NoContainerForRefImmediateComposite extends NavigationProblem {
		attr String[1] className;
		attr String[1] metamodelName;			   
	}

	@description(name="Different branch types", text="[Disabled] The types of both if branches should be compatible. Perhaps this should be part of ocl compliance checkings...")	 
	@info(prec="static", path="no", severity="warning-ocl", when="model-dep", kind="navigation", phase="typing", source="none")
	class DifferentBranchTypes extends NavigationProblem, Warning {
	   ref types.Type[1] thenType;
	   ref types.Type[1] elseType;
	}
	
	abstract class BindingProblem extends LocalProblem {
		ref ecore.EStructuralFeature[0..1] feature;
		attr String[1] featureName;
	}

	abstract class ResolveTempProblem extends LocalProblem {
	}
	
	class NoBindingForCompulsoryFeature extends TargetModelConformanceProblem, BindingProblem {
	   
	}

	class BindingExpectedOneAssignedMany extends BindingProblem {
	   
	}	
	
	class PrimitiveBindingButObjectAssigned extends BindingProblem {
		
	}
	
	class ObjectBindingButPrimitiveAssigned extends BindingProblem {
		
	}

	class PrimitiveBindingInvalidAssignment extends BindingProblem {
		
	}

	abstract class BindingResolution {
	   	ref ecore.EClass[1] rightType;	
		ref ecore.EClass[1] targetType;

        // Transitioning from eclass references to model elements
	    val ModelElement[1] right;
	    val ModelElement[1] left;
	    
		val ResolvedRuleInfo[*] rules;
	}

	class BindingWithoutRule extends BindingProblem, BindingResolution {			   
	}
	
	class BindingWithResolvedByIncompatibleRule extends BindingProblem, BindingResolution {
	}

	class BindingPossiblyUnresolved extends BindingProblem, BindingResolution {
	   ref EClass[+] problematicClasses;
	}
	
	class ResolvedRuleInfo {	   	
	   	attr String[1] location;
	   	ref  EObject[1] element;
	   	ref  EObject[1..*] allInvolvedRules;
	   	
	   	attr String[1] ruleName;
	   	
		ref ecore.EClass[0..1] inputType;  
		ref ecore.EClass[0..1] outputType;  
	}

	class ResolveTempWithoutRule extends ResolveTempProblem {			   
	   	ref ecore.EClass[0..1] sourceType;
	}

	class ResolveTempOutputPatternElementNotFound extends ResolveTempProblem {			   
	   	ref ecore.EClass[0..1] sourceType;
		val ResolvedRuleInfo[*] rules;	   	
	}


	class FlattenOverNonNestedCollection extends LocalProblem {
	   
	}
	
	class IteratorOverEmptySequence extends LocalProblem {
	   
	}
	
	class ReadingTargetModel extends LocalProblem {
		attr String[1] modelName;
	}

	class LazyRuleWithFilter extends LocalProblem {
		
	}

	class AmbiguousTargetModelReference extends LocalProblem {
		attr String[1] modelName;		
	}

	class NoModelFound extends LocalProblem {
		attr String[1] modelName;				
	}
	
	abstract class WrongType extends LocalProblem {
		
	}
	
	class IteratorBodyWrongType extends WrongType {
		
	}

	class MatchedRuleWithoutOutputPattern extends LocalProblem {
		// Possibly using the matched rule as entrypint rule (see Measure2XHTML)
	}

	class ExpectedCollectionInForEach extends LocalProblem {
		
	}

	class NoClassFoundInMetamodel extends LocalProblem {
		attr String[1] className;
	}

	class InvalidArgument extends LocalProblem {
		
	}

	class CollectionOperationNotFound extends LocalProblem {
		attr String[1] operationName;	
	}

	class IteratorOverNoCollectionType extends LocalProblem {
		attr String[1] iteratorName;	
	}

	abstract class AbstractIncoherentVariableDeclaration extends LocalProblem, OclCompliance {
		ref  types.Type[1] inferred;	   
		ref  types.Type[1] declared;	   		
	}	
	
	class IncoherentVariableDeclaration extends AbstractIncoherentVariableDeclaration {   		
	}
	
	class IncoherentHelperReturnType extends AbstractIncoherentVariableDeclaration {   		
	}
	
	class OperationOverCollectionType extends OclComplianceProblem {
		
	}

    // Not sure if it sometimes requires constraint solving...
	class AccessToUndefinedValue extends LocalProblem {
		
	}	
	
}

@namespace(uri="http://bento/analysis/atl/analysis/recovery", prefix="atl_recovery")
package atl_recovery {
	/*
	class FeatureFoundInSubclass extends Recovery {
		attr String[1] subclassName;
		ref  EClass[1] subclass;
	}
	*/
	
	class TentativeTypeAssigned extends Recovery {
	   ref types.Type[1] type;
	}
}
// References to typing ... 

@namespace(uri="http://bento/analysis/atl/analysis/errors/ide", prefix="ide_error")
package ide_error {
	class CouldNotLoadMetamodel extends atl_error.LocalProblem {
		attr String[1] uri;	
	}
}

/* Others errors that coud be checked */
/* - Invalid uses of oclIsKindOf (those that do not make sense) */
/* - Misuses of abstract classes */
